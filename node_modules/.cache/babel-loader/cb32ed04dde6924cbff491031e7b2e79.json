{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst bytewords = 'ableacidalsoapexaquaarchatomauntawayaxisbackbaldbarnbeltbetabiasbluebodybragbrewbulbbuzzcalmcashcatschefcityclawcodecolacookcostcruxcurlcuspcyandarkdatadaysdelidicedietdoordowndrawdropdrumdulldutyeacheasyechoedgeepicevenexamexiteyesfactfairfernfigsfilmfishfizzflapflewfluxfoxyfreefrogfuelfundgalagamegeargemsgiftgirlglowgoodgraygrimgurugushgyrohalfhanghardhawkheathelphighhillholyhopehornhutsicedideaidleinchinkyintoirisironitemjadejazzjoinjoltjowljudojugsjumpjunkjurykeepkenokeptkeyskickkilnkingkitekiwiknoblamblavalazyleaflegsliarlimplionlistlogoloudloveluaulucklungmainmanymathmazememomenumeowmildmintmissmonknailnavyneednewsnextnoonnotenumbobeyoboeomitonyxopenovalowlspaidpartpeckplaypluspoempoolposepuffpumapurrquadquizraceramprealredorichroadrockroofrubyruinrunsrustsafesagascarsetssilkskewslotsoapsolosongstubsurfswantacotasktaxitenttiedtimetinytoiltombtoystriptunatwinuglyundouniturgeuservastveryvetovialvibeviewvisavoidvowswallwandwarmwaspwavewaxywebswhatwhenwhizwolfworkyankyawnyellyogayurtzapszerozestzinczonezoom';\nlet bytewordsLookUpTable = [];\nconst BYTEWORDS_NUM = 256;\nconst BYTEWORD_LENGTH = 4;\nconst MINIMAL_BYTEWORD_LENGTH = 2;\nvar STYLES;\n\n(function (STYLES) {\n  STYLES[\"STANDARD\"] = \"standard\";\n  STYLES[\"URI\"] = \"uri\";\n  STYLES[\"MINIMAL\"] = \"minimal\";\n})(STYLES || (STYLES = {}));\n\nconst getWord = index => {\n  return bytewords.slice(index * BYTEWORD_LENGTH, index * BYTEWORD_LENGTH + BYTEWORD_LENGTH);\n};\n\nconst getMinimalWord = index => {\n  const byteword = getWord(index);\n  return `${byteword[0]}${byteword[BYTEWORD_LENGTH - 1]}`;\n};\n\nconst addCRC = string => {\n  const crc = utils_1.getCRCHex(Buffer.from(string, 'hex'));\n  return `${string}${crc}`;\n};\n\nconst encodeWithSeparator = (word, separator) => {\n  const crcAppendedWord = addCRC(word);\n  const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  const result = crcWordBuff.reduce((result, w) => [...result, getWord(w)], []);\n  return result.join(separator);\n};\n\nconst encodeMinimal = word => {\n  const crcAppendedWord = addCRC(word);\n  const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  const result = crcWordBuff.reduce((result, w) => result + getMinimalWord(w), '');\n  return result;\n};\n\nconst decodeWord = (word, wordLength) => {\n  assert_1.default(word.length === wordLength, 'Invalid Bytewords: word.length does not match wordLength provided');\n  const dim = 26; // Since the first and last letters of each Byteword are unique,\n  // we can use them as indexes into a two-dimensional lookup table.\n  // This table is generated lazily.\n\n  if (bytewordsLookUpTable.length === 0) {\n    const array_len = dim * dim;\n    bytewordsLookUpTable = [...new Array(array_len)].map(() => -1);\n\n    for (let i = 0; i < BYTEWORDS_NUM; i++) {\n      const byteword = getWord(i);\n      let x = byteword[0].charCodeAt(0) - 'a'.charCodeAt(0);\n      let y = byteword[3].charCodeAt(0) - 'a'.charCodeAt(0);\n      let offset = y * dim + x;\n      bytewordsLookUpTable[offset] = i;\n    }\n  } // If the coordinates generated by the first and last letters are out of bounds,\n  // or the lookup table contains -1 at the coordinates, then the word is not valid.\n\n\n  let x = word[0].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n  let y = word[wordLength == 4 ? 3 : 1].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n  assert_1.default(0 <= x && x < dim && 0 <= y && y < dim, 'Invalid Bytewords: invalid word');\n  let offset = y * dim + x;\n  let value = bytewordsLookUpTable[offset];\n  assert_1.default(value !== -1, 'Invalid Bytewords: value not in lookup table'); // If we're decoding a full four-letter word, verify that the two middle letters are correct.\n\n  if (wordLength == BYTEWORD_LENGTH) {\n    const byteword = getWord(value);\n    let c1 = word[1].toLowerCase();\n    let c2 = word[2].toLowerCase();\n    assert_1.default(c1 === byteword[1] && c2 === byteword[2], 'Invalid Bytewords: invalid middle letters of word');\n  } // Successful decode.\n\n\n  return Buffer.from([value]).toString('hex');\n};\n\nconst _decode = (string, separator, wordLength) => {\n  const words = wordLength == BYTEWORD_LENGTH ? string.split(separator) : utils_1.partition(string, 2);\n  const decodedString = words.map(word => decodeWord(word, wordLength)).join('');\n  assert_1.default(decodedString.length >= 5, 'Invalid Bytewords: invalid decoded string length');\n  const [body, bodyChecksum] = utils_1.split(Buffer.from(decodedString, 'hex'), 4);\n  const checksum = utils_1.getCRCHex(body); // convert to hex\n\n  assert_1.default(checksum === bodyChecksum.toString('hex'), 'Invalid Checksum');\n  return body.toString('hex');\n};\n\nconst decode = function (string) {\n  let style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STYLES.MINIMAL;\n\n  switch (style) {\n    case STYLES.STANDARD:\n      return _decode(string, ' ', BYTEWORD_LENGTH);\n\n    case STYLES.URI:\n      return _decode(string, '-', BYTEWORD_LENGTH);\n\n    case STYLES.MINIMAL:\n      return _decode(string, '', MINIMAL_BYTEWORD_LENGTH);\n\n    default:\n      throw new Error(`Invalid style ${style}`);\n  }\n};\n\nconst encode = function (string) {\n  let style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STYLES.MINIMAL;\n\n  switch (style) {\n    case STYLES.STANDARD:\n      return encodeWithSeparator(string, ' ');\n\n    case STYLES.URI:\n      return encodeWithSeparator(string, '-');\n\n    case STYLES.MINIMAL:\n      return encodeMinimal(string);\n\n    default:\n      throw new Error(`Invalid style ${style}`);\n  }\n};\n\nexports.default = {\n  decode,\n  encode,\n  STYLES\n};","map":{"version":3,"mappings":"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","names":["bytewords","bytewordsLookUpTable","BYTEWORDS_NUM","BYTEWORD_LENGTH","MINIMAL_BYTEWORD_LENGTH","STYLES","getWord","index","slice","getMinimalWord","byteword","addCRC","string","crc","utils_1","Buffer","from","encodeWithSeparator","word","separator","crcAppendedWord","crcWordBuff","result","reduce","w","join","encodeMinimal","decodeWord","wordLength","assert_1","length","dim","array_len","Array","map","i","x","charCodeAt","y","offset","toLowerCase","value","c1","c2","toString","_decode","words","split","decodedString","body","bodyChecksum","checksum","decode","style","MINIMAL","STANDARD","URI","Error","encode","exports"],"sourceRoot":"","sources":["../src/bytewords.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}