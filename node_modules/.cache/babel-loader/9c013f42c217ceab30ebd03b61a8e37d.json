{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FountainDecoderPart = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nconst fountainUtils_1 = require(\"./fountainUtils\");\n\nconst errors_1 = require(\"./errors\");\n\nclass FountainDecoderPart {\n  constructor(_indexes, _fragment) {\n    this._indexes = _indexes;\n    this._fragment = _fragment;\n  }\n\n  get indexes() {\n    return this._indexes;\n  }\n\n  get fragment() {\n    return this._fragment;\n  }\n\n  static fromEncoderPart(encoderPart) {\n    const indexes = fountainUtils_1.chooseFragments(encoderPart.seqNum, encoderPart.seqLength, encoderPart.checksum);\n    const fragment = encoderPart.fragment;\n    return new FountainDecoderPart(indexes, fragment);\n  }\n\n  isSimple() {\n    return this.indexes.length === 1;\n  }\n\n}\n\nexports.FountainDecoderPart = FountainDecoderPart;\n\nclass FountainDecoder {\n  constructor() {\n    this.result = undefined;\n    this.expectedMessageLength = 0;\n    this.expectedChecksum = 0;\n    this.expectedFragmentLength = 0;\n    this.processedPartsCount = 0;\n    this.expectedPartIndexes = [];\n    this.lastPartIndexes = [];\n    this.queuedParts = [];\n    this.receivedPartIndexes = [];\n    this.mixedParts = [];\n    this.simpleParts = [];\n  }\n\n  validatePart(part) {\n    // If this is the first part we've seen\n    if (this.expectedPartIndexes.length === 0) {\n      // Record the things that all the other parts we see will have to match to be valid.\n      [...new Array(part.seqLength)].forEach((_, index) => this.expectedPartIndexes.push(index));\n      this.expectedMessageLength = part.messageLength;\n      this.expectedChecksum = part.checksum;\n      this.expectedFragmentLength = part.fragment.length;\n    } else {\n      // If this part's values don't match the first part's values, throw away the part\n      if (this.expectedPartIndexes.length !== part.seqLength) {\n        return false;\n      }\n\n      if (this.expectedMessageLength !== part.messageLength) {\n        return false;\n      }\n\n      if (this.expectedChecksum !== part.checksum) {\n        return false;\n      }\n\n      if (this.expectedFragmentLength !== part.fragment.length) {\n        return false;\n      }\n    } // This part should be processed\n\n\n    return true;\n  }\n\n  reducePartByPart(a, b) {\n    // If the fragments mixed into `b` are a strict (proper) subset of those in `a`...\n    if (utils_1.arrayContains(a.indexes, b.indexes)) {\n      const newIndexes = utils_1.setDifference(a.indexes, b.indexes);\n      const newFragment = utils_1.bufferXOR(a.fragment, b.fragment);\n      return new FountainDecoderPart(newIndexes, newFragment);\n    } else {\n      // `a` is not reducable by `b`, so return a\n      return a;\n    }\n  }\n\n  reduceMixedBy(part) {\n    const newMixed = [];\n    this.mixedParts.map(_ref => {\n      let {\n        value: mixedPart\n      } = _ref;\n      return this.reducePartByPart(mixedPart, part);\n    }).forEach(reducedPart => {\n      if (reducedPart.isSimple()) {\n        this.queuedParts.push(reducedPart);\n      } else {\n        newMixed.push({\n          key: reducedPart.indexes,\n          value: reducedPart\n        });\n      }\n    });\n    this.mixedParts = newMixed;\n  }\n\n  processSimplePart(part) {\n    // Don't process duplicate parts\n    const fragmentIndex = part.indexes[0];\n\n    if (this.receivedPartIndexes.includes(fragmentIndex)) {\n      return;\n    }\n\n    this.simpleParts.push({\n      key: part.indexes,\n      value: part\n    });\n    this.receivedPartIndexes.push(fragmentIndex); // If we've received all the parts\n\n    if (utils_1.arraysEqual(this.receivedPartIndexes, this.expectedPartIndexes)) {\n      // Reassemble the message from its fragments\n      const sortedParts = this.simpleParts.map(_ref2 => {\n        let {\n          value\n        } = _ref2;\n        return value;\n      }).sort((a, b) => a.indexes[0] - b.indexes[0]);\n      const message = FountainDecoder.joinFragments(sortedParts.map(part => part.fragment), this.expectedMessageLength);\n      const checksum = utils_1.getCRC(message);\n\n      if (checksum === this.expectedChecksum) {\n        this.result = message;\n      } else {\n        this.error = new errors_1.InvalidChecksumError();\n      }\n    } else {\n      this.reduceMixedBy(part);\n    }\n  }\n\n  processMixedPart(part) {\n    // Don't process duplicate parts\n    if (this.mixedParts.some(_ref3 => {\n      let {\n        key: indexes\n      } = _ref3;\n      return utils_1.arraysEqual(indexes, part.indexes);\n    })) {\n      return;\n    } // Reduce this part by all the others\n\n\n    let p2 = this.simpleParts.reduce((acc, _ref4) => {\n      let {\n        value: p\n      } = _ref4;\n      return this.reducePartByPart(acc, p);\n    }, part);\n    p2 = this.mixedParts.reduce((acc, _ref5) => {\n      let {\n        value: p\n      } = _ref5;\n      return this.reducePartByPart(acc, p);\n    }, p2); // If the part is now simple\n\n    if (p2.isSimple()) {\n      // Add it to the queue\n      this.queuedParts.push(p2);\n    } else {\n      this.reduceMixedBy(p2);\n      this.mixedParts.push({\n        key: p2.indexes,\n        value: p2\n      });\n    }\n  }\n\n  processQueuedItem() {\n    if (this.queuedParts.length === 0) {\n      return;\n    }\n\n    const part = this.queuedParts.shift();\n\n    if (part.isSimple()) {\n      this.processSimplePart(part);\n    } else {\n      this.processMixedPart(part);\n    }\n  }\n\n  receivePart(encoderPart) {\n    if (this.isComplete()) {\n      return false;\n    }\n\n    if (!this.validatePart(encoderPart)) {\n      return false;\n    }\n\n    const decoderPart = FountainDecoderPart.fromEncoderPart(encoderPart);\n    this.lastPartIndexes = decoderPart.indexes;\n    this.queuedParts.push(decoderPart);\n\n    while (!this.isComplete() && this.queuedParts.length > 0) {\n      this.processQueuedItem();\n    }\n\n    ;\n    this.processedPartsCount += 1;\n    return true;\n  }\n\n  isComplete() {\n    return Boolean(this.result !== undefined && this.result.length > 0);\n  }\n\n  isSuccess() {\n    return Boolean(this.error === undefined && this.isComplete());\n  }\n\n  resultMessage() {\n    return this.isSuccess() ? this.result : Buffer.from([]);\n  }\n\n  isFailure() {\n    return this.error !== undefined;\n  }\n\n  resultError() {\n    return this.error ? this.error.message : '';\n  }\n\n  expectedPartCount() {\n    return this.expectedPartIndexes.length;\n  }\n\n  getExpectedPartIndexes() {\n    return [...this.expectedPartIndexes];\n  }\n\n  getReceivedPartIndexes() {\n    return [...this.receivedPartIndexes];\n  }\n\n  getLastPartIndexes() {\n    return [...this.lastPartIndexes];\n  }\n\n  estimatedPercentComplete() {\n    if (this.isComplete()) {\n      return 1;\n    }\n\n    const expectedPartCount = this.expectedPartCount();\n\n    if (expectedPartCount === 0) {\n      return 0;\n    } // We multiply the expectedPartCount by `1.75` as a way to compensate for the facet\n    // that `this.processedPartsCount` also tracks the duplicate parts that have been\n    // processeed.\n\n\n    return Math.min(0.99, this.processedPartsCount / (expectedPartCount * 1.75));\n  }\n\n  getProgress() {\n    if (this.isComplete()) {\n      return 1;\n    }\n\n    const expectedPartCount = this.expectedPartCount();\n\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n\n    return this.receivedPartIndexes.length / expectedPartCount;\n  }\n\n}\n\nexports.default = FountainDecoder;\n\nFountainDecoder.joinFragments = (fragments, messageLength) => {\n  return Buffer.concat(fragments).slice(0, messageLength);\n};","map":{"version":3,"mappings":"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","names":["FountainDecoderPart","constructor","_indexes","_fragment","indexes","fragment","fromEncoderPart","encoderPart","fountainUtils_1","seqNum","seqLength","checksum","isSimple","length","exports","FountainDecoder","undefined","validatePart","part","expectedPartIndexes","Array","forEach","_","index","push","expectedMessageLength","messageLength","expectedChecksum","expectedFragmentLength","reducePartByPart","a","b","utils_1","newIndexes","newFragment","reduceMixedBy","newMixed","mixedParts","map","value","mixedPart","reducedPart","queuedParts","key","processSimplePart","fragmentIndex","receivedPartIndexes","includes","simpleParts","sortedParts","sort","message","joinFragments","result","error","errors_1","processMixedPart","some","p2","reduce","acc","p","processQueuedItem","shift","receivePart","isComplete","decoderPart","lastPartIndexes","processedPartsCount","Boolean","isSuccess","resultMessage","Buffer","from","isFailure","resultError","expectedPartCount","getExpectedPartIndexes","getReceivedPartIndexes","getLastPartIndexes","estimatedPercentComplete","Math","min","getProgress","fragments","concat","slice"],"sourceRoot":"","sources":["../src/fountainDecoder.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}