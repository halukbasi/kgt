{"ast":null,"code":"/* global module */\n\n/**\n * Library for sampling of random values from a discrete probability distribution, \n * using the Walker-Vose alias method.\n *\n * Creates a new Sample instance for the given probabilities and outcomes.\n *\n * @param {Array} the probabilities.\n * @param {Array} the outcomes. Index is assumed as outcome if not provided.\n */\nfunction Sample(probabilities, outcomes, rng) {\n  'use strict';\n\n  this.alias = [];\n  this.prob = [];\n  this.outcomes = outcomes || this.indexedOutcomes(probabilities.length);\n  this.rng = rng || Math.random;\n  this.precomputeAlias(probabilities);\n}\n/**\n * Samples outcomes from the underlying probability distribution.\n *\n * @param {int} the number of samples. Optional parameter, defaults to 1.\n * @return {Object} a random outcome according to the underlying probability distribution \n *                  and the requested number of samples. If the requested number of samples \n *                  is greater than 1 this method returns an array.\n */\n\n\nSample.prototype.next = function (numOfSamples) {\n  'use strict';\n\n  var n = numOfSamples || 1,\n      out = [],\n      i = 0;\n\n  do {\n    var c = Math.floor(this.rng() * this.prob.length);\n    out[i] = this.outcomes[this.rng() < this.prob[c] ? c : this.alias[c]];\n  } while (++i < n);\n\n  return n > 1 ? out : out[0];\n};\n/**\n * Ported from ransampl.c\n * Scientific Computing Group of JCNS at MLZ Garching.\n * http://apps.jcns.fz-juelich.de/doku/sc/ransampl\n */\n\n\nSample.prototype.precomputeAlias = function (p) {\n  'use strict';\n\n  var n = p.length,\n      sum = 0,\n      nS = 0,\n      nL = 0,\n      P = [],\n      S = [],\n      L = [],\n      g,\n      i,\n      a; // Normalize probabilities\n\n  for (i = 0; i < n; ++i) {\n    if (p[i] < 0) {\n      throw 'Probability must be a positive: p[' + i + ']=' + p[i];\n    }\n\n    sum += p[i];\n  }\n\n  if (sum === 0) {\n    throw 'Probability cannot be zero.';\n  }\n\n  for (i = 0; i < n; ++i) {\n    P[i] = p[i] * n / sum;\n  } // Set separate index lists for small and large probabilities:\n\n\n  for (i = n - 1; i >= 0; --i) {\n    // at variance from Schwarz, we revert the index order\n    if (P[i] < 1) S[nS++] = i;else L[nL++] = i;\n  } // Work through index lists\n\n\n  while (nS && nL) {\n    a = S[--nS]; // Schwarz's l\n\n    g = L[--nL]; // Schwarz's g\n\n    this.prob[a] = P[a];\n    this.alias[a] = g;\n    P[g] = P[g] + P[a] - 1;\n    if (P[g] < 1) S[nS++] = g;else L[nL++] = g;\n  }\n\n  while (nL) this.prob[L[--nL]] = 1;\n\n  while (nS) // can only happen through numeric instability\n  this.prob[S[--nS]] = 1;\n};\n\nSample.prototype.indexedOutcomes = function (n) {\n  'use strict';\n\n  var o = [];\n\n  for (var i = 0; i < n; i++) o[i] = i;\n\n  return o;\n};\n\nSample.prototype.randomInt = function (min, max) {\n  'use strict';\n\n  return Math.floor(this.rng() * (max - min)) + min;\n};\n\nmodule.exports = function (probabilities, outcomes, rng) {\n  'use strict';\n\n  return new Sample(probabilities, outcomes, rng);\n};","map":{"version":3,"names":["Sample","probabilities","outcomes","rng","alias","prob","indexedOutcomes","length","Math","random","precomputeAlias","prototype","next","numOfSamples","n","out","i","c","floor","p","sum","nS","nL","P","S","L","g","a","o","randomInt","min","max","module","exports"],"sources":["/home/haluk/react-website-v1/node_modules/@apocentre/alias-sampling/index.js"],"sourcesContent":["/* global module */\n\n/**\n * Library for sampling of random values from a discrete probability distribution, \n * using the Walker-Vose alias method.\n *\n * Creates a new Sample instance for the given probabilities and outcomes.\n *\n * @param {Array} the probabilities.\n * @param {Array} the outcomes. Index is assumed as outcome if not provided.\n */\nfunction Sample(probabilities, outcomes, rng) {\n  'use strict';\n\n  this.alias = [];\n  this.prob  = [];\n  this.outcomes = outcomes || this.indexedOutcomes(probabilities.length);\n  this.rng = rng || Math.random\n  this.precomputeAlias(probabilities);\n}\n\n/**\n * Samples outcomes from the underlying probability distribution.\n *\n * @param {int} the number of samples. Optional parameter, defaults to 1.\n * @return {Object} a random outcome according to the underlying probability distribution \n *                  and the requested number of samples. If the requested number of samples \n *                  is greater than 1 this method returns an array.\n */\nSample.prototype.next = function (numOfSamples) {\n  'use strict';\n\n  var n   = numOfSamples || 1,\n      out = [],\n      i   = 0;\n\n  do {\n    var c = Math.floor(this.rng() * this.prob.length);\n    out[i] = this.outcomes[(this.rng() < this.prob[c]) ? c : this.alias[c]];\n  } while (++i < n);\n\n  return (n > 1) ? out : out[0];\n};\n\n/**\n * Ported from ransampl.c\n * Scientific Computing Group of JCNS at MLZ Garching.\n * http://apps.jcns.fz-juelich.de/doku/sc/ransampl\n */\nSample.prototype.precomputeAlias = function (p) {\n  'use strict';\n\n  var n   = p.length,\n      sum = 0,\n      nS  = 0,\n      nL  = 0,\n      P   = [],\n      S   = [],\n      L   = [],\n      g, i, a;\n\n  // Normalize probabilities\n  for (i = 0; i < n; ++i) {\n    if (p[i] < 0) {\n      throw 'Probability must be a positive: p[' + i + ']=' + p[i];\n    }\n    sum += p[i];\n  }\n\n  if (sum === 0) {\n    throw 'Probability cannot be zero.';\n  }\n\n  for (i = 0; i < n; ++i) {\n    P[i] = p[i] * n / sum;\n  }\n\n  // Set separate index lists for small and large probabilities:\n  for (i = n - 1; i >= 0; --i) {\n    // at variance from Schwarz, we revert the index order\n    if (P[i] < 1)\n      S[nS++] = i;\n    else\n      L[nL++] = i;\n  }\n\n  // Work through index lists\n  while (nS && nL) {\n    a = S[--nS]; // Schwarz's l\n    g = L[--nL]; // Schwarz's g\n\n    this.prob[a] = P[a];\n    this.alias[a] = g;\n\n    P[g] = P[g] + P[a] - 1;\n    if (P[g] < 1)\n      S[nS++] = g;\n    else\n      L[nL++] = g;\n  }\n\n  while (nL)\n    this.prob[L[--nL]] = 1;\n\n  while (nS)\n    // can only happen through numeric instability\n    this.prob[S[--nS]] = 1;\n};\n\nSample.prototype.indexedOutcomes = function (n) {\n  'use strict';\n\n  var o = [];\n  for (var i = 0; i < n; i++) o[i] = i;\n  return o;\n};\n\nSample.prototype.randomInt = function (min, max) {\n  'use strict';\n\n  return Math.floor(this.rng() * (max - min)) + min;\n};\n\nmodule.exports = function (probabilities, outcomes, rng) {\n  'use strict';\n\n  return new Sample(probabilities, outcomes, rng);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}