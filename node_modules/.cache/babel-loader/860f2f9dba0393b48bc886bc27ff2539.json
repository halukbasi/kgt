{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoAccount = void 0;\n\nconst _1 = require(\".\");\n\nconst lib_1 = require(\"./lib\");\n\nconst RegistryItem_1 = require(\"./RegistryItem\");\n\nconst RegistryType_1 = require(\"./RegistryType\");\n\nvar Keys;\n\n(function (Keys) {\n  Keys[Keys[\"masterFingerprint\"] = 1] = \"masterFingerprint\";\n  Keys[Keys[\"outputDescriptors\"] = 2] = \"outputDescriptors\";\n})(Keys || (Keys = {}));\n\nclass CryptoAccount extends RegistryItem_1.RegistryItem {\n  constructor(masterFingerprint, outputDescriptors) {\n    super();\n    this.masterFingerprint = masterFingerprint;\n    this.outputDescriptors = outputDescriptors;\n\n    this.getRegistryType = () => {\n      return RegistryType_1.RegistryTypes.CRYPTO_ACCOUNT;\n    };\n\n    this.getMasterFingerprint = () => this.masterFingerprint;\n\n    this.getOutputDescriptors = () => this.outputDescriptors;\n\n    this.toDataItem = () => {\n      const map = {};\n\n      if (this.masterFingerprint) {\n        map[Keys.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);\n      }\n\n      if (this.outputDescriptors) {\n        map[Keys.outputDescriptors] = this.outputDescriptors.map(item => item.toDataItem());\n      }\n\n      return new lib_1.DataItem(map);\n    };\n  }\n\n}\n\nexports.CryptoAccount = CryptoAccount;\n\nCryptoAccount.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const masterFingerprint = Buffer.alloc(4);\n  const _masterFingerprint = map[Keys.masterFingerprint];\n\n  if (_masterFingerprint) {\n    masterFingerprint.writeUInt32BE(_masterFingerprint, 0);\n  }\n\n  const outputDescriptors = map[Keys.outputDescriptors];\n  const cryptoOutputs = outputDescriptors.map(item => _1.CryptoOutput.fromDataItem(item));\n  return new CryptoAccount(masterFingerprint, cryptoOutputs);\n};\n\nCryptoAccount.fromCBOR = _cborPayload => {\n  const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);\n  return CryptoAccount.fromDataItem(dataItem);\n};","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AAGA,IAAKA,IAAL;;AAAA,WAAKA,IAAL,EAAS;EACPA;EACAA;AACD,CAHD,EAAKA,IAAI,KAAJA,IAAI,MAAT;;AAKA,MAAaC,aAAb,SAAmCC,2BAAnC,CAA+C;EAK7CC,YACUC,iBADV,EAEUC,iBAFV,EAE2C;IAEzC;IAHQ;IACA;;IANV,uBAAkB,MAAK;MACrB,OAAOC,6BAAcC,cAArB;IACD,CAFD;;IAWO,4BAAuB,MAAM,KAAKH,iBAAlC;;IACA,4BAAuB,MAAM,KAAKC,iBAAlC;;IAEA,kBAAa,MAAK;MACvB,MAAMG,GAAG,GAAgB,EAAzB;;MACA,IAAI,KAAKJ,iBAAT,EAA4B;QAC1BI,GAAG,CAACR,IAAI,CAACI,iBAAN,CAAH,GAA8B,KAAKA,iBAAL,CAAuBK,YAAvB,CAAoC,CAApC,CAA9B;MACD;;MACD,IAAI,KAAKJ,iBAAT,EAA4B;QAC1BG,GAAG,CAACR,IAAI,CAACK,iBAAN,CAAH,GAA8B,KAAKA,iBAAL,CAAuBG,GAAvB,CAA4BE,IAAD,IACvDA,IAAI,CAACC,UAAL,EAD4B,CAA9B;MAGD;;MACD,OAAO,IAAIC,cAAJ,CAAaJ,GAAb,CAAP;IACD,CAXM;EALN;;AAV4C;;AAA/CK;;AA4BgBZ,6BAAgBa,QAAD,IAAuB;EAClD,MAAMN,GAAG,GAAGM,QAAQ,CAACC,OAAT,EAAZ;EACA,MAAMX,iBAAiB,GAAGY,MAAM,CAACC,KAAP,CAAa,CAAb,CAA1B;EACA,MAAMC,kBAAkB,GAAGV,GAAG,CAACR,IAAI,CAACI,iBAAN,CAA9B;;EACA,IAAIc,kBAAJ,EAAwB;IACtBd,iBAAiB,CAACe,aAAlB,CAAgCD,kBAAhC,EAAoD,CAApD;EACD;;EACD,MAAMb,iBAAiB,GAAGG,GAAG,CAACR,IAAI,CAACK,iBAAN,CAA7B;EACA,MAAMe,aAAa,GAAGf,iBAAiB,CAACG,GAAlB,CAAuBE,IAAD,IAC1CW,gBAAaC,YAAb,CAA0BZ,IAA1B,CADoB,CAAtB;EAGA,OAAO,IAAIT,aAAJ,CAAkBG,iBAAlB,EAAqCgB,aAArC,CAAP;AACD,CAZa;;AAcAnB,yBAAYsB,YAAD,IAAyB;EAChD,MAAMT,QAAQ,GAAG,4BAAiBS,YAAjB,CAAjB;EACA,OAAOtB,aAAa,CAACqB,YAAd,CAA2BR,QAA3B,CAAP;AACD,CAHa","names":["Keys","CryptoAccount","RegistryItem_1","constructor","masterFingerprint","outputDescriptors","RegistryType_1","CRYPTO_ACCOUNT","map","readUInt32BE","item","toDataItem","lib_1","exports","dataItem","getData","Buffer","alloc","_masterFingerprint","writeUInt32BE","cryptoOutputs","_1","fromDataItem","_cborPayload"],"sourceRoot":"","sources":["../src/CryptoAccount.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}