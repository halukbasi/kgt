{"ast":null,"code":"import EventEmitter from 'eventemitter3';\nimport { PublicKey } from '@solana/web3.js';\nimport bs58 from 'bs58';\n\nclass Wallet extends EventEmitter {\n  constructor(provider, network) {\n    var _this;\n\n    super();\n    _this = this;\n\n    this._handleMessage = e => {\n      if (this._injectedProvider && e.source === window || e.origin === this._providerUrl.origin && e.source === this._popup) {\n        if (e.data.method === 'connected') {\n          const newPublicKey = new PublicKey(e.data.params.publicKey);\n\n          if (!this._publicKey || !this._publicKey.equals(newPublicKey)) {\n            if (this._publicKey && !this._publicKey.equals(newPublicKey)) {\n              this._handleDisconnect();\n            }\n\n            this._publicKey = newPublicKey;\n            this._autoApprove = !!e.data.params.autoApprove;\n            this.emit('connect', this._publicKey);\n          }\n        } else if (e.data.method === 'disconnected') {\n          this._handleDisconnect();\n        } else if (e.data.result || e.data.error) {\n          if (this._responsePromises.has(e.data.id)) {\n            const [resolve, reject] = this._responsePromises.get(e.data.id);\n\n            if (e.data.result) {\n              resolve(e.data.result);\n            } else {\n              reject(new Error(e.data.error));\n            }\n          }\n        }\n      }\n    };\n\n    this._handleConnect = () => {\n      if (!this._handlerAdded) {\n        this._handlerAdded = true;\n        window.addEventListener('message', this._handleMessage);\n        window.addEventListener('beforeunload', this.disconnect);\n      }\n\n      if (this._injectedProvider) {\n        return new Promise(resolve => {\n          this._sendRequest('connect', {});\n\n          resolve();\n        });\n      } else {\n        window.name = 'parent';\n        this._popup = window.open(this._providerUrl.toString(), '_blank', 'location,resizable,width=460,height=675');\n        return new Promise(resolve => {\n          this.once('connect', resolve);\n        });\n      }\n    };\n\n    this._handleDisconnect = () => {\n      if (this._handlerAdded) {\n        this._handlerAdded = false;\n        window.removeEventListener('message', this._handleMessage);\n        window.removeEventListener('beforeunload', this.disconnect);\n      }\n\n      if (this._publicKey) {\n        this._publicKey = null;\n        this.emit('disconnect');\n      }\n\n      this._responsePromises.forEach((_ref, id) => {\n        let [resolve, reject] = _ref;\n\n        this._responsePromises.delete(id);\n\n        reject('Wallet disconnected');\n      });\n    };\n\n    this._sendRequest = async function (method, params) {\n      if (method !== 'connect' && !_this.connected) {\n        throw new Error('Wallet not connected');\n      }\n\n      const requestId = _this._nextRequestId;\n      ++_this._nextRequestId;\n      return new Promise((resolve, reject) => {\n        _this._responsePromises.set(requestId, [resolve, reject]);\n\n        if (_this._injectedProvider) {\n          _this._injectedProvider.postMessage({\n            jsonrpc: '2.0',\n            id: requestId,\n            method,\n            params: {\n              network: _this._network,\n              ...params\n            }\n          });\n        } else {\n          _this._popup.postMessage({\n            jsonrpc: '2.0',\n            id: requestId,\n            method,\n            params\n          }, _this._providerUrl.origin);\n\n          if (!_this.autoApprove) {\n            _this._popup.focus();\n          }\n        }\n      });\n    };\n\n    this.connect = () => {\n      if (this._popup) {\n        this._popup.close();\n      }\n\n      return this._handleConnect();\n    };\n\n    this.disconnect = async function () {\n      if (_this._injectedProvider) {\n        await _this._sendRequest('disconnect', {});\n      }\n\n      if (_this._popup) {\n        _this._popup.close();\n      }\n\n      _this._handleDisconnect();\n    };\n\n    this.sign = async function (data, display) {\n      if (!(data instanceof Uint8Array)) {\n        throw new Error('Data must be an instance of Uint8Array');\n      }\n\n      const response = await _this._sendRequest('sign', {\n        data,\n        display\n      });\n      const signature = bs58.decode(response.signature);\n      const publicKey = new PublicKey(response.publicKey);\n      return {\n        signature,\n        publicKey\n      };\n    };\n\n    this.signTransaction = async function (transaction) {\n      const response = await _this._sendRequest('signTransaction', {\n        message: bs58.encode(transaction.serializeMessage())\n      });\n      const signature = bs58.decode(response.signature);\n      const publicKey = new PublicKey(response.publicKey);\n      transaction.addSignature(publicKey, signature);\n      return transaction;\n    };\n\n    this.signAllTransactions = async function (transactions) {\n      const response = await _this._sendRequest('signAllTransactions', {\n        messages: transactions.map(tx => bs58.encode(tx.serializeMessage()))\n      });\n      const signatures = response.signatures.map(s => bs58.decode(s));\n      const publicKey = new PublicKey(response.publicKey);\n      transactions = transactions.map((tx, idx) => {\n        tx.addSignature(publicKey, signatures[idx]);\n        return tx;\n      });\n      return transactions;\n    };\n\n    if (isInjectedProvider(provider)) {\n      this._injectedProvider = provider;\n    } else if (isString(provider)) {\n      this._providerUrl = new URL(provider);\n      this._providerUrl.hash = new URLSearchParams({\n        origin: window.location.origin,\n        network\n      }).toString();\n    } else {\n      throw new Error('provider parameter must be an injected provider or a URL string.');\n    }\n\n    this._network = network;\n    this._publicKey = null;\n    this._autoApprove = false;\n    this._popup = null;\n    this._handlerAdded = false;\n    this._nextRequestId = 1;\n    this._responsePromises = new Map();\n  }\n\n  get publicKey() {\n    return this._publicKey;\n  }\n\n  get connected() {\n    return this._publicKey !== null;\n  }\n\n  get autoApprove() {\n    return this._autoApprove;\n  }\n\n}\n\nfunction isString(a) {\n  return typeof a === 'string';\n}\n\nfunction isInjectedProvider(a) {\n  return isObject(a) && isFunction(a.postMessage);\n}\n\nfunction isObject(a) {\n  return typeof a === 'object' && a !== null;\n}\n\nfunction isFunction(a) {\n  return typeof a === 'function';\n}\n\nexport default Wallet;","map":{"version":3,"mappings":"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","names":["Wallet","EventEmitter","constructor","provider","network","_this","_handleMessage","e","_injectedProvider","source","window","origin","_providerUrl","_popup","data","method","newPublicKey","PublicKey","params","publicKey","_publicKey","equals","_handleDisconnect","_autoApprove","autoApprove","emit","result","error","_responsePromises","has","id","resolve","reject","get","Error","_handleConnect","_handlerAdded","addEventListener","disconnect","Promise","_sendRequest","name","open","toString","once","removeEventListener","forEach","delete","connected","requestId","_nextRequestId","set","postMessage","jsonrpc","_network","focus","connect","close","sign","display","Uint8Array","response","signature","bs58","decode","signTransaction","transaction","message","encode","serializeMessage","addSignature","signAllTransactions","transactions","messages","map","tx","signatures","s","idx","isInjectedProvider","isString","URL","hash","URLSearchParams","location","Map","a","isObject","isFunction"],"sources":["../src/index.js"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { PublicKey } from '@solana/web3.js';\nimport bs58 from 'bs58';\n\nexport default class Wallet extends EventEmitter {\n  constructor(provider, network) {\n    super();\n    if (isInjectedProvider(provider)) {\n      this._injectedProvider = provider;\n    } else if (isString(provider)) {\n      this._providerUrl = new URL(provider);\n      this._providerUrl.hash = new URLSearchParams({\n        origin: window.location.origin,\n        network,\n      }).toString();\n    } else {\n      throw new Error(\n        'provider parameter must be an injected provider or a URL string.',\n      );\n    }\n    this._network = network;\n    this._publicKey = null;\n    this._autoApprove = false;\n    this._popup = null;\n    this._handlerAdded = false;\n    this._nextRequestId = 1;\n    this._responsePromises = new Map();\n  }\n\n  _handleMessage = (e) => {\n    if (\n      (this._injectedProvider && e.source === window) ||\n      (e.origin === this._providerUrl.origin && e.source === this._popup)\n    ) {\n      if (e.data.method === 'connected') {\n        const newPublicKey = new PublicKey(e.data.params.publicKey);\n        if (!this._publicKey || !this._publicKey.equals(newPublicKey)) {\n          if (this._publicKey && !this._publicKey.equals(newPublicKey)) {\n            this._handleDisconnect();\n          }\n          this._publicKey = newPublicKey;\n          this._autoApprove = !!e.data.params.autoApprove;\n          this.emit('connect', this._publicKey);\n        }\n      } else if (e.data.method === 'disconnected') {\n        this._handleDisconnect();\n      } else if (e.data.result || e.data.error) {\n        if (this._responsePromises.has(e.data.id)) {\n          const [resolve, reject] = this._responsePromises.get(e.data.id);\n          if (e.data.result) {\n            resolve(e.data.result);\n          } else {\n            reject(new Error(e.data.error));\n          }\n        }\n      }\n    }\n  };\n\n  _handleConnect = () => {\n    if (!this._handlerAdded) {\n      this._handlerAdded = true;\n      window.addEventListener('message', this._handleMessage);\n      window.addEventListener('beforeunload', this.disconnect);\n    }\n    if (this._injectedProvider) {\n      return new Promise((resolve) => {\n        this._sendRequest('connect', {});\n        resolve();\n      });\n    } else {\n      window.name = 'parent';\n      this._popup = window.open(\n        this._providerUrl.toString(),\n        '_blank',\n        'location,resizable,width=460,height=675',\n      );\n      return new Promise((resolve) => {\n        this.once('connect', resolve);\n      });\n    }\n  };\n\n  _handleDisconnect = () => {\n    if (this._handlerAdded) {\n      this._handlerAdded = false;\n      window.removeEventListener('message', this._handleMessage);\n      window.removeEventListener('beforeunload', this.disconnect);\n    }\n    if (this._publicKey) {\n      this._publicKey = null;\n      this.emit('disconnect');\n    }\n    this._responsePromises.forEach(([resolve, reject], id) => {\n      this._responsePromises.delete(id);\n      reject('Wallet disconnected');\n    });\n  };\n\n  _sendRequest = async (method, params) => {\n    if (method !== 'connect' && !this.connected) {\n      throw new Error('Wallet not connected');\n    }\n    const requestId = this._nextRequestId;\n    ++this._nextRequestId;\n    return new Promise((resolve, reject) => {\n      this._responsePromises.set(requestId, [resolve, reject]);\n      if (this._injectedProvider) {\n        this._injectedProvider.postMessage({\n          jsonrpc: '2.0',\n          id: requestId,\n          method,\n          params: {\n            network: this._network,\n            ...params,\n          },\n        });\n      } else {\n        this._popup.postMessage(\n          {\n            jsonrpc: '2.0',\n            id: requestId,\n            method,\n            params,\n          },\n          this._providerUrl.origin,\n        );\n\n        if (!this.autoApprove) {\n          this._popup.focus();\n        }\n      }\n    });\n  };\n\n  get publicKey() {\n    return this._publicKey;\n  }\n\n  get connected() {\n    return this._publicKey !== null;\n  }\n\n  get autoApprove() {\n    return this._autoApprove;\n  }\n\n  connect = () => {\n    if (this._popup) {\n      this._popup.close();\n    }\n    return this._handleConnect();\n  };\n\n  disconnect = async () => {\n    if (this._injectedProvider) {\n      await this._sendRequest('disconnect', {});\n    }\n    if (this._popup) {\n      this._popup.close();\n    }\n    this._handleDisconnect();\n  };\n\n  sign = async (data, display) => {\n    if (!(data instanceof Uint8Array)) {\n      throw new Error('Data must be an instance of Uint8Array');\n    }\n\n    const response = await this._sendRequest('sign', {\n      data,\n      display,\n    });\n    const signature = bs58.decode(response.signature);\n    const publicKey = new PublicKey(response.publicKey);\n    return {\n      signature,\n      publicKey,\n    };\n  };\n\n  signTransaction = async (transaction) => {\n    const response = await this._sendRequest('signTransaction', {\n      message: bs58.encode(transaction.serializeMessage()),\n    });\n    const signature = bs58.decode(response.signature);\n    const publicKey = new PublicKey(response.publicKey);\n    transaction.addSignature(publicKey, signature);\n    return transaction;\n  };\n\n  signAllTransactions = async (transactions) => {\n    const response = await this._sendRequest('signAllTransactions', {\n      messages: transactions.map((tx) => bs58.encode(tx.serializeMessage())),\n    });\n    const signatures = response.signatures.map((s) => bs58.decode(s));\n    const publicKey = new PublicKey(response.publicKey);\n    transactions = transactions.map((tx, idx) => {\n      tx.addSignature(publicKey, signatures[idx]);\n      return tx;\n    });\n    return transactions;\n  };\n}\n\nfunction isString(a) {\n  return typeof a === 'string';\n}\n\nfunction isInjectedProvider(a) {\n  return isObject(a) && isFunction(a.postMessage);\n}\n\nfunction isObject(a) {\n  return typeof a === 'object' && a !== null;\n}\n\nfunction isFunction(a) {\n  return typeof a === 'function';\n}\n"]},"metadata":{},"sourceType":"module"}