{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FountainEncoderPart = void 0;\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst fountainUtils_1 = require(\"./fountainUtils\");\n\nconst cbor_1 = require(\"./cbor\");\n\nclass FountainEncoderPart {\n  constructor(_seqNum, _seqLength, _messageLength, _checksum, _fragment) {\n    this._seqNum = _seqNum;\n    this._seqLength = _seqLength;\n    this._messageLength = _messageLength;\n    this._checksum = _checksum;\n    this._fragment = _fragment;\n  }\n\n  get messageLength() {\n    return this._messageLength;\n  }\n\n  get fragment() {\n    return this._fragment;\n  }\n\n  get seqNum() {\n    return this._seqNum;\n  }\n\n  get seqLength() {\n    return this._seqLength;\n  }\n\n  get checksum() {\n    return this._checksum;\n  }\n\n  cbor() {\n    const result = cbor_1.cborEncode([this._seqNum, this._seqLength, this._messageLength, this._checksum, this._fragment]);\n    return Buffer.from(result);\n  }\n\n  description() {\n    return `seqNum:${this._seqNum}, seqLen:${this._seqLength}, messageLen:${this._messageLength}, checksum:${this._checksum}, data:${this._fragment.toString('hex')}`;\n  }\n\n  static fromCBOR(cborPayload) {\n    const [seqNum, seqLength, messageLength, checksum, fragment] = cbor_1.cborDecode(cborPayload);\n    assert_1.default(typeof seqNum === 'number');\n    assert_1.default(typeof seqLength === 'number');\n    assert_1.default(typeof messageLength === 'number');\n    assert_1.default(typeof checksum === 'number');\n    assert_1.default(Buffer.isBuffer(fragment) && fragment.length > 0);\n    return new FountainEncoderPart(seqNum, seqLength, messageLength, checksum, Buffer.from(fragment));\n  }\n\n}\n\nexports.FountainEncoderPart = FountainEncoderPart;\n\nclass FountainEncoder {\n  constructor(message) {\n    let maxFragmentLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    let firstSeqNum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let minFragmentLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n    const fragmentLength = FountainEncoder.findNominalFragmentLength(message.length, minFragmentLength, maxFragmentLength);\n    this._messageLength = message.length;\n    this._fragments = FountainEncoder.partitionMessage(message, fragmentLength);\n    this.fragmentLength = fragmentLength;\n    this.seqNum = utils_1.toUint32(firstSeqNum);\n    this.checksum = utils_1.getCRC(message);\n  }\n\n  get fragmentsLength() {\n    return this._fragments.length;\n  }\n\n  get fragments() {\n    return this._fragments;\n  }\n\n  get messageLength() {\n    return this._messageLength;\n  }\n\n  isComplete() {\n    return this.seqNum >= this._fragments.length;\n  }\n\n  isSinglePart() {\n    return this._fragments.length === 1;\n  }\n\n  seqLength() {\n    return this._fragments.length;\n  }\n\n  mix(indexes) {\n    return indexes.reduce((result, index) => utils_1.bufferXOR(this._fragments[index], result), Buffer.alloc(this.fragmentLength, 0));\n  }\n\n  nextPart() {\n    this.seqNum = utils_1.toUint32(this.seqNum + 1);\n    const indexes = fountainUtils_1.chooseFragments(this.seqNum, this._fragments.length, this.checksum);\n    const mixed = this.mix(indexes);\n    return new FountainEncoderPart(this.seqNum, this._fragments.length, this._messageLength, this.checksum, mixed);\n  }\n\n  static findNominalFragmentLength(messageLength, minFragmentLength, maxFragmentLength) {\n    assert_1.default(messageLength > 0);\n    assert_1.default(minFragmentLength > 0);\n    assert_1.default(maxFragmentLength >= minFragmentLength);\n    const maxFragmentCount = Math.ceil(messageLength / minFragmentLength);\n    let fragmentLength = 0;\n\n    for (let fragmentCount = 1; fragmentCount <= maxFragmentCount; fragmentCount++) {\n      fragmentLength = Math.ceil(messageLength / fragmentCount);\n\n      if (fragmentLength <= maxFragmentLength) {\n        break;\n      }\n    }\n\n    return fragmentLength;\n  }\n\n  static partitionMessage(message, fragmentLength) {\n    let remaining = Buffer.from(message);\n    let fragment;\n    let _fragments = [];\n\n    while (remaining.length > 0) {\n      [fragment, remaining] = utils_1.split(remaining, -fragmentLength);\n      fragment = Buffer.alloc(fragmentLength, 0) // initialize with 0's to achieve the padding\n      .fill(fragment, 0, fragment.length);\n\n      _fragments.push(fragment);\n    }\n\n    return _fragments;\n  }\n\n}\n\nexports.default = FountainEncoder;","map":{"version":3,"mappings":"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","names":["FountainEncoderPart","constructor","_seqNum","_seqLength","_messageLength","_checksum","_fragment","messageLength","fragment","seqNum","seqLength","checksum","cbor","result","cbor_1","Buffer","from","description","toString","fromCBOR","cborPayload","assert_1","isBuffer","length","exports","FountainEncoder","message","maxFragmentLength","firstSeqNum","minFragmentLength","fragmentLength","findNominalFragmentLength","_fragments","partitionMessage","utils_1","fragmentsLength","fragments","isComplete","isSinglePart","mix","indexes","reduce","index","alloc","nextPart","fountainUtils_1","mixed","maxFragmentCount","Math","ceil","fragmentCount","remaining","fill","push"],"sourceRoot":"","sources":["../src/fountainEncoder.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}