{"ast":null,"code":"import { useContext, useRef, useLayoutEffect } from 'react';\nimport { useThree } from '@react-three/fiber';\nimport { useVisualElementContext, calcLength } from 'framer-motion';\nimport { MotionCanvasContext } from './MotionCanvasContext.mjs';\nimport { invariant } from 'hey-listen';\nimport { clamp } from 'popmotion';\n\nconst calcBoxSize = _ref => {\n  let {\n    x,\n    y\n  } = _ref;\n  return {\n    width: calcLength(x),\n    height: calcLength(y),\n    top: 0,\n    left: 0\n  };\n};\n\nfunction useLayoutCamera(_ref2, updateCamera) {\n  let {\n    makeDefault = true\n  } = _ref2;\n  const context = useContext(MotionCanvasContext);\n  invariant(Boolean(context), \"No MotionCanvas detected. Replace Canvas from @react-three/fiber with MotionCanvas from framer-motion.\");\n  const {\n    dimensions,\n    layoutCamera,\n    requestedDpr\n  } = context;\n  const advance = useThree(three => three.advance);\n  const set = useThree(three => three.set);\n  const camera = useThree(three => three.camera);\n  const size = useThree(three => three.size);\n  const gl = useThree(three => three.gl);\n  const parentVisualElement = useVisualElementContext();\n  const measuredLayoutSize = useRef();\n  useLayoutEffect(() => {\n    measuredLayoutSize.current = size;\n    updateCamera(size);\n    advance(performance.now());\n    const projection = parentVisualElement === null || parentVisualElement === void 0 ? void 0 : parentVisualElement.projection;\n    if (!projection) return;\n    /**\n     * When the projection of an element changes we want to update the camera\n     * with the projected dimensions.\n     */\n\n    const removeProjectionUpdateListener = projection.addEventListener(\"projectionUpdate\", newProjection => updateCamera(calcBoxSize(newProjection)));\n    /**\n     * When the layout of an element changes we want to update the renderer\n     * output to match the layout dimensions.\n     */\n\n    const removeLayoutMeasureListener = projection.addEventListener(\"measure\", newLayout => {\n      const newSize = calcBoxSize(newLayout);\n      let dpr = requestedDpr;\n      const {\n        width,\n        height\n      } = dimensions.current.size;\n      const xScale = width / newSize.width;\n      const yScale = height / newSize.height;\n      const maxScale = Math.max(xScale, yScale);\n      dpr = clamp(0.75, 4, maxScale);\n      dimensions.current = {\n        size: {\n          width: newSize.width,\n          height: newSize.height\n        },\n        dpr\n      };\n      gl.setSize(newSize.width, newSize.height);\n      gl.setPixelRatio(dpr);\n    });\n    /**\n     * When a projection animation completes we want to update the camera to\n     * match the recorded layout of the element.\n     */\n\n    const removeAnimationCompleteListener = projection.addEventListener(\"animationComplete\", () => {\n      const {\n        actual\n      } = projection.layout || {};\n\n      if (actual) {\n        setTimeout(() => {\n          const newSize = calcBoxSize(actual);\n          updateCamera(newSize);\n          dimensions.current = {\n            size: newSize\n          };\n          gl.setSize(newSize.width, newSize.height);\n          gl.setPixelRatio(requestedDpr);\n        }, 50);\n      }\n    });\n    return () => {\n      removeProjectionUpdateListener();\n      removeLayoutMeasureListener();\n      removeAnimationCompleteListener();\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  useLayoutEffect(() => {\n    const {\n      current: cam\n    } = layoutCamera;\n\n    if (makeDefault && cam) {\n      const oldCam = camera;\n      set(() => ({\n        camera: cam\n      }));\n      return () => set(() => ({\n        camera: oldCam\n      }));\n    }\n  }, [camera, layoutCamera, makeDefault, set]);\n  return {\n    size,\n    camera,\n    cameraRef: layoutCamera\n  };\n}\n\nexport { useLayoutCamera };","map":{"version":3,"names":["useContext","useRef","useLayoutEffect","useThree","useVisualElementContext","calcLength","MotionCanvasContext","invariant","clamp","calcBoxSize","x","y","width","height","top","left","useLayoutCamera","updateCamera","makeDefault","context","Boolean","dimensions","layoutCamera","requestedDpr","advance","three","set","camera","size","gl","parentVisualElement","measuredLayoutSize","current","performance","now","projection","removeProjectionUpdateListener","addEventListener","newProjection","removeLayoutMeasureListener","newLayout","newSize","dpr","xScale","yScale","maxScale","Math","max","setSize","setPixelRatio","removeAnimationCompleteListener","actual","layout","setTimeout","cam","oldCam","cameraRef"],"sources":["/home/haluk/react-website-v1/node_modules/framer-motion-3d/dist/es/components/use-layout-camera.mjs"],"sourcesContent":["import { useContext, useRef, useLayoutEffect } from 'react';\nimport { useThree } from '@react-three/fiber';\nimport { useVisualElementContext, calcLength } from 'framer-motion';\nimport { MotionCanvasContext } from './MotionCanvasContext.mjs';\nimport { invariant } from 'hey-listen';\nimport { clamp } from 'popmotion';\n\nconst calcBoxSize = ({ x, y }) => ({\n    width: calcLength(x),\n    height: calcLength(y),\n    top: 0,\n    left: 0,\n});\nfunction useLayoutCamera({ makeDefault = true }, updateCamera) {\n    const context = useContext(MotionCanvasContext);\n    invariant(Boolean(context), \"No MotionCanvas detected. Replace Canvas from @react-three/fiber with MotionCanvas from framer-motion.\");\n    const { dimensions, layoutCamera, requestedDpr } = context;\n    const advance = useThree((three) => three.advance);\n    const set = useThree((three) => three.set);\n    const camera = useThree((three) => three.camera);\n    const size = useThree((three) => three.size);\n    const gl = useThree((three) => three.gl);\n    const parentVisualElement = useVisualElementContext();\n    const measuredLayoutSize = useRef();\n    useLayoutEffect(() => {\n        measuredLayoutSize.current = size;\n        updateCamera(size);\n        advance(performance.now());\n        const projection = parentVisualElement === null || parentVisualElement === void 0 ? void 0 : parentVisualElement.projection;\n        if (!projection)\n            return;\n        /**\n         * When the projection of an element changes we want to update the camera\n         * with the projected dimensions.\n         */\n        const removeProjectionUpdateListener = projection.addEventListener(\"projectionUpdate\", (newProjection) => updateCamera(calcBoxSize(newProjection)));\n        /**\n         * When the layout of an element changes we want to update the renderer\n         * output to match the layout dimensions.\n         */\n        const removeLayoutMeasureListener = projection.addEventListener(\"measure\", (newLayout) => {\n            const newSize = calcBoxSize(newLayout);\n            let dpr = requestedDpr;\n            const { width, height } = dimensions.current.size;\n            const xScale = width / newSize.width;\n            const yScale = height / newSize.height;\n            const maxScale = Math.max(xScale, yScale);\n            dpr = clamp(0.75, 4, maxScale);\n            dimensions.current = {\n                size: { width: newSize.width, height: newSize.height },\n                dpr,\n            };\n            gl.setSize(newSize.width, newSize.height);\n            gl.setPixelRatio(dpr);\n        });\n        /**\n         * When a projection animation completes we want to update the camera to\n         * match the recorded layout of the element.\n         */\n        const removeAnimationCompleteListener = projection.addEventListener(\"animationComplete\", () => {\n            const { actual } = projection.layout || {};\n            if (actual) {\n                setTimeout(() => {\n                    const newSize = calcBoxSize(actual);\n                    updateCamera(newSize);\n                    dimensions.current = { size: newSize };\n                    gl.setSize(newSize.width, newSize.height);\n                    gl.setPixelRatio(requestedDpr);\n                }, 50);\n            }\n        });\n        return () => {\n            removeProjectionUpdateListener();\n            removeLayoutMeasureListener();\n            removeAnimationCompleteListener();\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    useLayoutEffect(() => {\n        const { current: cam } = layoutCamera;\n        if (makeDefault && cam) {\n            const oldCam = camera;\n            set(() => ({ camera: cam }));\n            return () => set(() => ({ camera: oldCam }));\n        }\n    }, [camera, layoutCamera, makeDefault, set]);\n    return { size, camera, cameraRef: layoutCamera };\n}\n\nexport { useLayoutCamera };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}