{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst fountainDecoder_1 = __importDefault(require(\"./fountainDecoder\"));\n\nconst bytewords_1 = __importDefault(require(\"./bytewords\"));\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst errors_1 = require(\"./errors\");\n\nconst ur_1 = __importDefault(require(\"./ur\"));\n\nconst fountainEncoder_1 = require(\"./fountainEncoder\");\n\nclass URDecoder {\n  constructor() {\n    let fountainDecoder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new fountainDecoder_1.default();\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bytes';\n    this.fountainDecoder = fountainDecoder;\n    this.type = type;\n    assert_1.default(utils_1.isURType(type), 'Invalid UR type');\n    this.expected_type = '';\n  }\n\n  static decodeBody(type, message) {\n    const cbor = bytewords_1.default.decode(message, bytewords_1.default.STYLES.MINIMAL);\n    return new ur_1.default(Buffer.from(cbor, 'hex'), type);\n  }\n\n  validatePart(type) {\n    if (this.expected_type) {\n      return this.expected_type === type;\n    }\n\n    if (!utils_1.isURType(type)) {\n      return false;\n    }\n\n    this.expected_type = type;\n    return true;\n  }\n\n  static decode(message) {\n    const [type, components] = this.parse(message);\n\n    if (components.length === 0) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n\n    const body = components[0];\n    return URDecoder.decodeBody(type, body);\n  }\n\n  static parse(message) {\n    const lowercase = message.toLowerCase();\n    const prefix = lowercase.slice(0, 3);\n\n    if (prefix !== 'ur:') {\n      throw new errors_1.InvalidSchemeError();\n    }\n\n    const components = lowercase.slice(3).split('/');\n    const type = components[0];\n\n    if (components.length < 2) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n\n    if (!utils_1.isURType(type)) {\n      throw new errors_1.InvalidTypeError();\n    }\n\n    return [type, components.slice(1)];\n  }\n\n  static parseSequenceComponent(s) {\n    const components = s.split('-');\n\n    if (components.length !== 2) {\n      throw new errors_1.InvalidSequenceComponentError();\n    }\n\n    const seqNum = utils_1.toUint32(Number(components[0]));\n    const seqLength = Number(components[1]);\n\n    if (seqNum < 1 || seqLength < 1) {\n      throw new errors_1.InvalidSequenceComponentError();\n    }\n\n    return [seqNum, seqLength];\n  }\n\n  receivePart(s) {\n    if (this.result !== undefined) {\n      return false;\n    }\n\n    const [type, components] = URDecoder.parse(s);\n\n    if (!this.validatePart(type)) {\n      return false;\n    } // If this is a single-part UR then we're done\n\n\n    if (components.length === 1) {\n      this.result = URDecoder.decodeBody(type, components[0]);\n      return true;\n    }\n\n    if (components.length !== 2) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n\n    const [seq, fragment] = components;\n    const [seqNum, seqLength] = URDecoder.parseSequenceComponent(seq);\n    const cbor = bytewords_1.default.decode(fragment, bytewords_1.default.STYLES.MINIMAL);\n    const part = fountainEncoder_1.FountainEncoderPart.fromCBOR(cbor);\n\n    if (seqNum !== part.seqNum || seqLength !== part.seqLength) {\n      return false;\n    }\n\n    if (!this.fountainDecoder.receivePart(part)) {\n      return false;\n    }\n\n    if (this.fountainDecoder.isSuccess()) {\n      this.result = new ur_1.default(this.fountainDecoder.resultMessage(), type);\n    } else if (this.fountainDecoder.isFailure()) {\n      this.error = new errors_1.InvalidSchemeError();\n    }\n\n    return true;\n  }\n\n  resultUR() {\n    return this.result ? this.result : new ur_1.default(Buffer.from([]));\n  }\n\n  isComplete() {\n    return this.result && this.result.cbor.length > 0;\n  }\n\n  isSuccess() {\n    return !this.error && this.isComplete();\n  }\n\n  isError() {\n    return this.error !== undefined;\n  }\n\n  resultError() {\n    return this.error ? this.error.message : '';\n  }\n\n  expectedPartCount() {\n    return this.fountainDecoder.expectedPartCount();\n  }\n\n  expectedPartIndexes() {\n    return this.fountainDecoder.getExpectedPartIndexes();\n  }\n\n  receivedPartIndexes() {\n    return this.fountainDecoder.getReceivedPartIndexes();\n  }\n\n  lastPartIndexes() {\n    return this.fountainDecoder.getLastPartIndexes();\n  }\n\n  estimatedPercentComplete() {\n    return this.fountainDecoder.estimatedPercentComplete();\n  }\n\n  getProgress() {\n    return this.fountainDecoder.getProgress();\n  }\n\n}\n\nexports.default = URDecoder;","map":{"version":3,"mappings":"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","names":["URDecoder","constructor","fountainDecoder","fountainDecoder_1","type","assert_1","utils_1","expected_type","decodeBody","message","cbor","bytewords_1","decode","STYLES","MINIMAL","ur_1","Buffer","from","validatePart","components","parse","length","errors_1","body","lowercase","toLowerCase","prefix","slice","split","parseSequenceComponent","s","seqNum","Number","seqLength","receivePart","result","undefined","seq","fragment","part","fountainEncoder_1","fromCBOR","isSuccess","resultMessage","isFailure","error","resultUR","isComplete","isError","resultError","expectedPartCount","expectedPartIndexes","getExpectedPartIndexes","receivedPartIndexes","getReceivedPartIndexes","lastPartIndexes","getLastPartIndexes","estimatedPercentComplete","getProgress","exports"],"sourceRoot":"","sources":["../src/urDecoder.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}