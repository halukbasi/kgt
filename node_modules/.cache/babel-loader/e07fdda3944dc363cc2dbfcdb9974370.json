{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scopePollingDetectionStrategy = exports.BaseWalletAdapter = exports.WalletReadyState = exports.EventEmitter = void 0;\n\nconst eventemitter3_1 = __importDefault(require(\"eventemitter3\"));\n\nexports.EventEmitter = eventemitter3_1.default;\n\nconst errors_1 = require(\"./errors\");\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */\n\n\nvar WalletReadyState;\n\n(function (WalletReadyState) {\n  /**\n   * User-installable wallets can typically be detected by scanning for an API\n   * that they've injected into the global context. If such an API is present,\n   * we consider the wallet to have been installed.\n   */\n  WalletReadyState[\"Installed\"] = \"Installed\";\n  WalletReadyState[\"NotDetected\"] = \"NotDetected\";\n  /**\n   * Loadable wallets are always available to you. Since you can load them at\n   * any time, it's meaningless to say that they have been detected.\n   */\n\n  WalletReadyState[\"Loadable\"] = \"Loadable\";\n  /**\n   * If a wallet is not supported on a given platform (eg. server-rendering, or\n   * mobile) then it will stay in the `Unsupported` state.\n   */\n\n  WalletReadyState[\"Unsupported\"] = \"Unsupported\";\n})(WalletReadyState = exports.WalletReadyState || (exports.WalletReadyState = {}));\n\nclass BaseWalletAdapter extends eventemitter3_1.default {\n  get connected() {\n    return !!this.publicKey;\n  }\n\n  prepareTransaction(transaction, connection) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      const publicKey = this.publicKey;\n      if (!publicKey) throw new errors_1.WalletNotConnectedError();\n      transaction.feePayer = transaction.feePayer || publicKey;\n      transaction.recentBlockhash = transaction.recentBlockhash || (yield connection.getLatestBlockhash(options === null || options === void 0 ? void 0 : options.preflightCommitment)).blockhash;\n      return transaction;\n    });\n  }\n\n}\n\nexports.BaseWalletAdapter = BaseWalletAdapter;\n\nfunction scopePollingDetectionStrategy(detect) {\n  // Early return when server-side rendering\n  if (typeof window === 'undefined' || typeof document === 'undefined') return;\n  const disposers = [];\n\n  function detectAndDispose() {\n    const detected = detect();\n\n    if (detected) {\n      for (const dispose of disposers) {\n        dispose();\n      }\n    }\n  } // Strategy #1: Try detecting every second.\n\n\n  const interval = // TODO: #334 Replace with idle callback strategy.\n  setInterval(detectAndDispose, 1000);\n  disposers.push(() => clearInterval(interval)); // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n\n  if ( // Implies that `DOMContentLoaded` has not yet fired.\n  document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', detectAndDispose, {\n      once: true\n    });\n    disposers.push(() => document.removeEventListener('DOMContentLoaded', detectAndDispose));\n  } // Strategy #3: Detect after the `window` has fully loaded.\n\n\n  if ( // If the `complete` state has been reached, we're too late.\n  document.readyState !== 'complete') {\n    window.addEventListener('load', detectAndDispose, {\n      once: true\n    });\n    disposers.push(() => window.removeEventListener('load', detectAndDispose));\n  } // Strategy #4: Detect synchronously, now.\n\n\n  detectAndDispose();\n}\n\nexports.scopePollingDetectionStrategy = scopePollingDetectionStrategy;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AAISA,uBAJFC,uBAIE;;AAFT;AAuCA;;;;;;;;;;;AASA,IAAYC,gBAAZ;;AAAA,WAAYA,gBAAZ,EAA4B;EACxB;;;;;EAKAA;EACAA;EACA;;;;;EAIAA;EACA;;;;;EAIAA;AACH,CAlBD,EAAYA,gBAAgB,GAAhBF,wDAAgB,EAAhB,CAAZ;;AAoBA,MAAsBG,iBAAtB,SAAgDF,uBAAhD,CAAiF;EAQhE,IAATG,SAAS;IACT,OAAO,CAAC,CAAC,KAAKC,SAAd;EACH;;EAUeC,kBAAkB,CAC9BC,WAD8B,EAE9BC,UAF8B,EAGL;IAAA,IAAzBC,OAAyB,uEAAF,EAAE;;MAEzB,MAAMJ,SAAS,GAAG,KAAKA,SAAvB;MACA,IAAI,CAACA,SAAL,EAAgB,MAAM,IAAIK,gCAAJ,EAAN;MAEhBH,WAAW,CAACI,QAAZ,GAAuBJ,WAAW,CAACI,QAAZ,IAAwBN,SAA/C;MACAE,WAAW,CAACK,eAAZ,GACIL,WAAW,CAACK,eAAZ,IACA,CAAC,MAAMJ,UAAU,CAACK,kBAAX,CAA8BJ,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEK,mBAAvC,CAAP,EAAoEC,SAFxE;MAIA,OAAOR,WAAP;IACH;EAAA;;AAlC4E;;AAAjFP;;AAqCA,SAAgBgB,6BAAhB,CAA8CC,MAA9C,EAAmE;EAC/D;EACA,IAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiC,OAAOC,QAAP,KAAoB,WAAzD,EAAsE;EAEtE,MAAMC,SAAS,GAAmB,EAAlC;;EAEA,SAASC,gBAAT,GAAyB;IACrB,MAAMC,QAAQ,GAAGL,MAAM,EAAvB;;IACA,IAAIK,QAAJ,EAAc;MACV,KAAK,MAAMC,OAAX,IAAsBH,SAAtB,EAAiC;QAC7BG,OAAO;MACV;IACJ;EACJ,CAb8D,CAe/D;;;EACA,MAAMC,QAAQ,GACV;EACAC,WAAW,CAACJ,gBAAD,EAAmB,IAAnB,CAFf;EAGAD,SAAS,CAACM,IAAV,CAAe,MAAMC,aAAa,CAACH,QAAD,CAAlC,EAnB+D,CAqB/D;;EACA,KACI;EACAL,QAAQ,CAACS,UAAT,KAAwB,SAF5B,EAGE;IACET,QAAQ,CAACU,gBAAT,CAA0B,kBAA1B,EAA8CR,gBAA9C,EAAgE;MAAES,IAAI,EAAE;IAAR,CAAhE;IACAV,SAAS,CAACM,IAAV,CAAe,MAAMP,QAAQ,CAACY,mBAAT,CAA6B,kBAA7B,EAAiDV,gBAAjD,CAArB;EACH,CA5B8D,CA8B/D;;;EACA,KACI;EACAF,QAAQ,CAACS,UAAT,KAAwB,UAF5B,EAGE;IACEV,MAAM,CAACW,gBAAP,CAAwB,MAAxB,EAAgCR,gBAAhC,EAAkD;MAAES,IAAI,EAAE;IAAR,CAAlD;IACAV,SAAS,CAACM,IAAV,CAAe,MAAMR,MAAM,CAACa,mBAAP,CAA2B,MAA3B,EAAmCV,gBAAnC,CAArB;EACH,CArC8D,CAuC/D;;;EACAA,gBAAgB;AACnB;;AAzCDrB","names":["exports","eventemitter3_1","WalletReadyState","BaseWalletAdapter","connected","publicKey","prepareTransaction","transaction","connection","options","errors_1","feePayer","recentBlockhash","getLatestBlockhash","preflightCommitment","blockhash","scopePollingDetectionStrategy","detect","window","document","disposers","detectAndDispose","detected","dispose","interval","setInterval","push","clearInterval","readyState","addEventListener","once","removeEventListener"],"sourceRoot":"","sources":["../../src/adapter.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}